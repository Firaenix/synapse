'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var buffer = require('buffer');
var bsv = require('bsv');

/**
 * Cast class
 * 
 * Casts are an abstraction over transaction input and outputs. A cast provides
 * a simple, unified way for developers to define self contained modules
 * representing `lockingScript` and `unlockingScript` templates.
 * 
 * The templates defined within a Cast are dynamic and allow complex scripts to
 * be build when given specific parameters.
 */
class Cast {
  /**
   * Instantiates a new Cast instance.
   * 
   * @param {Object} cast Cast template object
   * @constructor
   */
  constructor({script, size, setup, validate} = {}) {
    this.script = script || [];
    this.size = size;
    if (setup && typeof setup === 'function') {
      this.setup = setup;
    }
    if (validate && typeof validate === 'function') {
      this.validate = validate;
    }
  }

  /**
   * Instantiates a `lockingScript` Cast instance.
   * 
   * The following parameters are required:
   * 
   * * `satoshis` - the amount to send in the output (also accepts `amount`)
   * 
   * Additional parameters may be required, depending on the Cast template.
   * 
   * @param {Object} cast Cast template object
   * @param {Object} params Cast parameters
   * @constructor
   */
  static lockingScript(cast, params = {}) {
    requiresAny(params, 'lockingScript', [
      ['satoshis', 'amount']
    ]);

    const satoshis = params.satoshis || params.amount || 0;
    delete params.satoshis && delete params.amount;
    return new LockingScript(cast.lockingScript, satoshis, params)
  }

  /**
   * Instantiates an `unlockingScript` Cast instance.
   * 
   * The following parameters are required:
   * 
   * * `txid` - txid of the UTXO
   * * `script` - hex encoded script of the UTXO
   * * `satoshis` - the amount in the UTXO (also accepts `amount`)
   * * `vout` - the UTXO output index (also accepts `outputIndex` and `txOutNum`)
   * 
   * Additional parameters may be required, depending on the Cast template.
   * 
   * @param {Object} cast Cast template object
   * @param {Object} params Cast parameters
   * @constructor
   */
  static unlockingScript(cast, params = {}) {
    requires(params, 'unlockingScript', ['txid', 'script']);
    requiresAny(params, 'unlockingScript', [
      ['satoshis', 'amount'],
      ['vout', 'outputIndex', 'txOutNum']
    ]);

    const txid = params.txid,
          script = bsv.Script.fromHex(params.script),
          satoshis = params.satoshis || params.amount,
          satoshisBn = bsv.Bn(satoshis),
          txOut = bsv.TxOut.fromProperties(satoshisBn, script),
          nSequence = params.nSequence;
    
    let txOutNum;
    ['vout', 'outputIndex', 'txOutNum']
      .some(attr => {
        if (typeof params[attr] === 'number') return txOutNum = params[attr]
      });

    delete params.txid && delete params.script;
    delete params.satoshis && delete params.amount;
    delete params.vout && delete params.outputIndex && delete params.txOutNum;

    return new UnlockingScript(cast.unlockingScript, txid, txOutNum, txOut, nSequence, params)
  }

  /**
   * Returns the full generated script.
   * 
   * Iterrates over the template and builds the script chunk by chunk.
   * 
   * @returns {Script}
   */
  getScript(ctx, params) {
    let args;
    if (typeof params === 'undefined') {
      params = { ...this.params, ...ctx };
      params = { ...params, ...this.setup(params) };
      args = [params];
    } else {
      params = { ...this.params, ...params };
      params = { ...params, ...this.setup(params) };
      args = [ctx, params];
    }

    this.validate(...args);

    return this.script.reduce((script, chunk) => {
      let data = typeof chunk === 'function' ? chunk(...args) : chunk;
      if (typeof data === 'undefined') return script;

      if (data.buffer instanceof ArrayBuffer) {
        script.writeBuffer(data);
      } else if (typeof data === 'number') {
        script.writeOpCode(data);
      } else if (data.chunks) {
        script.writeScript(data);
      }
      
      return script
    }, new bsv.Script())
  }

  /**
   * Returns the estimated size of the script, based on the Cast template.
   * 
   * @returns {Number}
   */
  getSize() {
    let size;
    if (typeof this.size === 'function') {
      size = this.size(this.params);
    } else if (typeof this.size === 'number') {
      size = this.size;
    } else {
      // If no size prop is given on the cast, we must roughly estimate
      console.warn("No 'size' prop given on the template. Size estimate may be innacurate.");
      size = this.script.reduce((sum, chunk) => {
        if (typeof chunk === 'function') {
          // This is horrible. We have no idea how large the data will be so
          // we just pluck a number out of thin air and say 20 bytes
          sum += 21;
        } else if (chunk.buffer instanceof ArrayBuffer) {
          sum += bsv.VarInt.fromNumber(chunk.length).buf.length + chunk.length;
        } else {
          sum += 1;
        }
        return sum
      }, 0);
    }

    return bsv.VarInt.fromNumber(size).buf.length + size
  }

  /**
   * Callback function that can be overriden in the Cast template.
   * 
   * Returning an Object from this function will make all properties in that
   * Object available to all chunks of the template.
   * 
   * @returns {Object}
   */
  setup() {
    // noop
  }

  /**
   * Callback function that can be overriden in the Cast template.
   * 
   * This is called after `setup()` and receives all parameters that the template
   * build functions receive. This provides a way to check parameters and throw
   * appropriate errors if the parameters aren't correct to build the script.
   * 
   * @param {Obejct} ctx
   * @param {Obejct} params
   */
  validate(...args) {
    // noop
  }
}


// Helper function to ensure all the specified attributes exist in the given
// params
function requires(params, type, attrs) {
  attrs.forEach(attr => {
    if (typeof params[attr] === 'undefined')
      throw new Error(`Cast type '${type}' requires '${attr}' param`)
  });
}

// Helper function to ensure any of the specified attributes exist in the given
// params
function requiresAny(params, type, attrs) {
  attrs.forEach(aliases => {
    if (aliases.every(attr => typeof params[attr] === 'undefined')) {
      throw new Error(`Cast type '${type}' requires '${aliases[0]}' param`)
    }
  });
}

/**
 * LockingScript Cast sub-class
 */
class LockingScript extends Cast {
  /**
   * Instantiates a new LockingScript instance.
   * 
   * @param {Object} cast Cast template object
   * @param {Number} satoshis Amount to send
   * @param {Object} params Other parameters
   * @constructor
   */
  constructor(cast, satoshis, params = {}) {
    super(cast);

    if (typeof satoshis === 'undefined') {
      throw new Error("Cast type 'lockingScript' requires 'satoshis' param")
    }

    this.satoshis = satoshis;
    this.params = params;
  }

  /**
   * Returns the estimated size of the entire TxOut object
   * 
   * @returns {Number}
   */
  getSize() {
    return super.getSize() + 8 // satoshis (8)
  }
}

/**
 * UnlockingScript Cast sub-class
 */
class UnlockingScript extends Cast {
  /**
   * Instantiates a new UnlockingScript instance.
   * 
   * @param {Object} cast Cast template object
   * @param {String} txid UTXO transaction id
   * @param {Number} txOutNum UTXO output index
   * @param {TxOut} txOut UTXO TxOut object
   * @param {Number} nSequence nSequence number
   * @constructor
   */
  constructor(cast, txid, txOutNum, txOut, nSequence, params = {}) {
    super(cast);

    const req = ['txid', 'txOutNum', 'txOut'];

    req.forEach(attr => {
      if (typeof eval(attr) === 'undefined')
        throw new Error(`Cast type 'unlockingScript' requires '${attr}' param`)
    });

    this.txid = txid;
    this.txHashBuf = buffer.Buffer.from(txid, 'hex').reverse();
    this.txOutNum = txOutNum;
    this.txOut = txOut;
    this.nSequence = nSequence;
    this.params = params;
  }

  /**
   * Returns the estimated size of the entire TxIn object
   * 
   * @returns {Number}
   */
  getSize() {
    return super.getSize() + 40 // txid (32), vout (4), nSquence (4)
  }

  /**
   * Returns the full generated script.
   * 
   * Adds a context object which is passed to each of the `unlockingScript`
   * template build functions.
   * 
   * @returns {Script}
   */
  getScript(forge, params) {
    const tx = forge.tx,
          txOutNum = forge.inputs.indexOf(this),
          txOut = this.txOut;
    
    return super.getScript({ tx, txOutNum, txOut}, params)
  }
}

/**
 * OP_RETURN cast
 * 
 * OP_RETURNS are frequently used to create transaction outputs containing
 * arbitrary data.
 * 
 * The cast automatically handles your given data array containing strings,
 * hex-strings, buffers and OpCodes, and processes it into a Script.
 */
const OP_RETURN = {
  /**
   * OP_RETURN lockingScript
   * 
   * The expected parameters are:
   * 
   * * `data` - an array of data chunks (see below)
   * * `safe` - set to false for spendable OP_RETURNS (defaults true)
   * 
   * The data array can contain any of the following types of element:
   * 
   * * Strings
   * * Hex-encoded strings, eg: `0xfafbfcfd`
   * * Raw buffers or typed arrays
   * * OpCode numbers
   * 
   * Example:
   * 
   * ```
   * Cast.lockingScript(OP_RETURN, {
   *   satoshis: 0,
   *   data: [
   *     '0x48656c6c6f20776f726c64',
   *     'Hello world',
   *     Buffer.from('Hello world'),
   *     new Uint8Array([72, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]),
   *     OpCode.OP_FALSE
   *   ]
   * })
   * ```
   */
  lockingScript: {
    script: [
      // 1. OP_FALSE (if safe)
      ({ safe = true }) => safe ? bsv.OpCode.OP_FALSE : undefined,

      // 2. OP_RETURN
      bsv.OpCode.OP_RETURN,

      // 3. Arbitrary data
      function({ data }) {
        // Iterates over data params and returns a Script instance
        return data.reduce((script, item) => {
          // Hex string
          if (typeof item === 'string' && /^0x/i.test(item)) {
            script.writeBuffer(buffer.Buffer.from(item.slice(2), 'hex'));
          }
          // Opcode number
          else if (typeof item === 'number' || item === null) {
            script.writeOpCode(Number.isInteger(item) ? item : 0);
          }
          // Opcode
          else if (typeof item === 'object' && item.hasOwnProperty('op')) {
            script.writeOpCode(item.op);
          }
          // All else
          else {
            script.writeBuffer(buffer.Buffer.from(item));
          }
          
          return script
        }, new bsv.Script())
      }
    ],

    /**
     * Returns the size of the script.
     * 
     * @param {Object} params Cast params
     * @returns {Number}
     */
    size(params) {
      const scriptLen = this.getScript(params).toBuffer().length;
      return (params.safe ? 1 : 0) + 1 + bsv.VarInt.fromNumber(scriptLen).buf.length + scriptLen
    },

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(params) {
      if (!(Array.isArray(params.data) && params.data.length)) {
        throw new Error('OP_RETURN script requires data array')
      }
    }
  }
};

/**
 * P2MS (multisig) cast
 * 
 * Build and spend multisig transactions, using the locking and unlocking
 * scripts available in this cast.
 */
const P2MS = {
  /**
   * P2MS lockingScript
   * 
   * The expected lock parameters are:
   * 
   * * `threshold` - the number of signatures required to unlock the UTXO
   * * `pubKeys` - array of bsv PubKey objects 
   * 
   * Example:
   * 
   * ```
   * // Creates 2 of 3 multisig lockingScript
   * Cast.lockingScript(P2MS, { satoshis: 1000, threshold: 2, pubKeys: [pk1, pk2, pk3] })
   * ```
   */
  lockingScript: {
    script: [
      // 1. Threshold Op
      ({ threshold }) => threshold + bsv.OpCode.OP_1 - 1,

      // 2. PubKeys
      function({ pubKeys }) {
        return pubKeys.reduce((script, pubKey) => {
          script.writeBuffer(pubKey.toBuffer());
          return script
        }, new bsv.Script())
      },

      // 3. PubKeys Op
      ({ pubKeys }) => pubKeys.length + bsv.OpCode.OP_1 - 1,

      // 4. OP_CHECKMULTISIG
      bsv.OpCode.OP_CHECKMULTISIG
    ],

    /**
     * Returns the size of the script.
     * 
     * @param {Object} params Cast params
     * @returns {Number}
     */
    size: ({ pubKeys }) => 2 + (pubKeys.length * 34),

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(params) {
      if (typeof params.threshold !== 'number') {
        throw new Error('P2MS lockingScript requires threshold (M-of-N)')
      }
      if (!(Array.isArray(params.pubKeys) && params.pubKeys.every(k => !!k.point))) {
        throw new Error('P2MS lockingScript requires pubKeys')
      }
    }
  },

  /**
   * P2MS unlockingScript
   * 
   * The expected unlock parameters are:
   * 
   * * `keyPairs` - array of bsv KeyPair objects
   * 
   * Example:
   * 
   * ```
   * // Creates unlockingScript from UTXO
   * Cast.unlockingScript(P2MS, { txid, txOutNum, txOut, nSequence })
   * 
   * // Sign the unlockingScript with 2 keyPairs (assuming vin 0)
   * forge.signTxIn(0, { keyPairs: [k1, k2] })
   * ```
   */
  unlockingScript: {
    script: [
      // 1. OP_0 required
      bsv.OpCode.OP_0,

      // 2. Sigs
      function(ctx, {
        keyPairs,
        sighashType = bsv.Sig.SIGHASH_ALL | bsv.Sig.SIGHASH_FORKID,
        flags = bsv.Tx.SCRIPT_ENABLE_SIGHASH_FORKID
      }) {
        const {tx, txOutNum, txOut} = ctx;
        const script = new bsv.Script();
        // Iterrate over each of the locking script pubKeys
        for (let i = 1; i < txOut.script.chunks.length-2; i++) {
          let keyPair = keyPairs.find(k => {
            return buffer.Buffer.compare(txOut.script.chunks[i].buf, k.pubKey.toBuffer()) === 0
          });
          const sig = tx.sign(keyPair, sighashType, txOutNum, txOut.script, txOut.valueBn, flags);
          script.writeBuffer(sig.toTxFormat());
        }
        return script
      }
    ],

    /**
     * Returns the size of the script.
     * 
     * @param {Object} params Cast params
     * @returns {Number}
     */
    size: (params) => 1 + ((params.keyPairs ? params.keyPairs.length : 2) * 73),
    

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(ctx, params) {
      if (!params.keyPairs) throw new Error('P2MS unlockingScript requires valid keyPairs')
      if (!verifyKeyPairs(params.keyPairs, ctx.txOut)) {
        throw new Error('P2MS unlockingScript keyPairs must match lockingScript pubKeys')
      }
    }
  }
};

// Helper function verifies all given keyPairs match pubKeys in txOut
function verifyKeyPairs(keyPairs, { script }) {
  return Array.isArray(keyPairs) && keyPairs.every(keyPair => {
    return !!(
      keyPair.pubKey &&
      script.chunks.some(c => {
        return c.buf && buffer.Buffer.compare(c.buf, keyPair.pubKey.toBuffer()) === 0
      })
    )
  })
}

/**
 * P2PK (pay-to-pubKey) cast
 * 
 * Build and spend pay-to-pubKey transactions, using the locking and unlocking
 * scripts available in this cast.
 */
const P2PK = {
  /**
   * P2PK lockingScript
   * 
   * The expected lock parameters are:
   * 
   * * `pubKey` - the bsv PubKey object to pay to
   * 
   * Example:
   * 
   * ```
   * // Creates P2PK lockingScript
   * Cast.lockingScript(P2PK, { satoshis: 1000, pubKey })
   * ```
   */
  lockingScript: {
    script: [
      // 1. PubKey
      ({ pubKey }) => pubKey.toBuffer(),

      // 2. OP_CHECKSIG
      bsv.OpCode.OP_CHECKSIG
    ],

    /**
     * Returns the size of the script.
     * 
     * @property {Object} size Script size
     */
    size: 35,

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(params) {
      if (!(params.pubKey && params.pubKey.point)) {
        throw new Error('P2PK lockingScript requires pubKey')
      }
    }
  },

  /**
   * P2PK unlockingScript
   * 
   * The expected unlock parameters are:
   * 
   * * `keyPair` - bsv KeyPair object
   * 
   * Example:
   * 
   * ```
   * // Creates unlockingScript from UTXO
   * Cast.unlockingScript(P2PK, { txid, txOutNum, txOut, nSequence })
   * 
   * // Sign the unlockingScript a keyPair (assuming vin 0)
   * forge.signTxIn(0, { keyPair })
   * ```
   */
  unlockingScript: {
    script: [
      // 1. Sig
      function(ctx, {
        keyPair,
        sighashType = bsv.Sig.SIGHASH_ALL | bsv.Sig.SIGHASH_FORKID,
        flags = bsv.Tx.SCRIPT_ENABLE_SIGHASH_FORKID
      }) {
        const {tx, txOutNum, txOut} = ctx;
        const sig = tx.sign(keyPair, sighashType, txOutNum, txOut.script, txOut.valueBn, flags);
        return sig.toTxFormat()
      }
    ],

    /**
     * Returns the size of the script.
     * 
     * @property {Object} size Script size
     */
    size: 73,

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(ctx, params) {
      if (!params.keyPair || !verifyKeyPair(params.keyPair, ctx.txOut)) {
        throw new Error('P2PK unlockingScript requires valid keyPair')
      }
    }
  }
};

// Helper function verifies the given keyPair matches the pubKey in txOut
function verifyKeyPair(keyPair, { script }) {
  return !!(
    script.chunks.length === 2 &&
    script.chunks[0].buf &&
    buffer.Buffer.compare(script.chunks[0].buf, keyPair.pubKey.toBuffer()) === 0
  )
}

/**
 * P2PKH (pay-to-pubKeyHash) cast
 * 
 * Build and spend pay-to-pubKeyHash transactions, using the locking and
 * unlocking scripts available in this cast.
 */
const P2PKH = {
  /**
   * P2PKH lockingScript
   * 
   * The expected lock parameters are:
   * 
   * * `address` - the bsv Address object to pay to
   * 
   * Example:
   * 
   * ```
   * // Creates P2PK lockingScript
   * Cast.lockingScript(P2PKH, { satoshis: 1000, address })
   * ```
   */
  lockingScript: {
    script: [
      // 1. OpCodes
      bsv.OpCode.OP_DUP,
      bsv.OpCode.OP_HASH160,

      // 2. PubKeyHash
      ({ address }) => address.hashBuf,

      // 3. OpCodes
      bsv.OpCode.OP_EQUALVERIFY,
      bsv.OpCode.OP_CHECKSIG
    ],

    /**
     * Returns the size of the script.
     * 
     * @property {Object} size Script size
     */
    size: 25,

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(params) {
      if (!(params.address && params.address.hashBuf)) {
        throw new Error('P2PKH lockingScript requires address')
      }
    }
  },

  /**
   * P2PKH unlockingScript
   * 
   * The expected unlock parameters are:
   * 
   * * `keyPair` - bsv KeyPair object
   * 
   * Example:
   * 
   * ```
   * // Creates unlockingScript from UTXO
   * Cast.unlockingScript(P2PKH, { txid, txOutNum, txOut, nSequence })
   * 
   * // Sign the unlockingScript a keyPair (assuming vin 0)
   * forge.signTxIn(0, { keyPair })
   * ```
   */
  unlockingScript: {
    script: [
      // 1. Sig
      function(ctx, {
        keyPair,
        sighashType = bsv.Sig.SIGHASH_ALL | bsv.Sig.SIGHASH_FORKID,
        flags = bsv.Tx.SCRIPT_ENABLE_SIGHASH_FORKID
      }) {
        const {tx, txOutNum, txOut} = ctx;
        const sig = tx.sign(keyPair, sighashType, txOutNum, txOut.script, txOut.valueBn, flags);
        return sig.toTxFormat()
      },

      // 2. PubKey
      (_ctx, { keyPair }) => keyPair.pubKey.toBuffer()
    ],

    /**
     * Returns the size of the script.
     * 
     * @property {Object} size Script size
     */
    size: 107,

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(ctx, params) {
      if (!(params.keyPair && verifyKeyPair$1(params.keyPair, ctx.txOut))) {
        throw new Error('P2PKH unlockingScript requires valid keyPair')
      }
    }
  }
};

// Helper function verifies the given keyPair matches the pubKey in txOut
function verifyKeyPair$1(keyPair, { script }) {
  const hashBuf = bsv.Address.fromPubKey(keyPair.pubKey).hashBuf;
  return !!(
    script.chunks.length === 5 &&
    script.chunks[2].buf &&
    buffer.Buffer.compare(script.chunks[2].buf, hashBuf) === 0
  )
}

// Patch OpCodes until added to bsv2
// https://github.com/moneybutton/bsv/issues/161
bsv.OpCode.OP_SPLIT = 0x7f;

const defaultRHash = 'PayToRHASH160';

/**
 * P2RPH (R-Puzzle) cast
 * 
 * Build and spend R-Puzzles, using the locking and unlocking scripts available
 * in this cast.
 * 
 * This cast wouldn't be possible without Dean Little revealing how R-Puzzles
 * actually work in his library, [rpuzzle](https://github.com/deanmlittle/rpuzzle).
 * Much of the code in this module is adapted from Dean's work.
 */
const P2RPH = {
  /**
   * P2RPH lockingScript
   * 
   * The expected lock parameters are:
   * 
   * * `type` - the hash algorithm to use (defaults to 'PayToRHASH160')
   * * `rBuf` - the R value in a Buffer or typed array
   * 
   * Example:
   * 
   * ```
   * // Creates R-Puzzle lockingScript
   * Cast.lockingScript(P2RPH, { satoshis: 0, rBuf })
   * ```
   */
  lockingScript: {
    script: [
      // 1. OpCodes
      bsv.OpCode.OP_OVER,
      bsv.OpCode.OP_3,
      bsv.OpCode.OP_SPLIT,
      bsv.OpCode.OP_NIP,
      bsv.OpCode.OP_1,
      bsv.OpCode.OP_SPLIT,
      bsv.OpCode.OP_SWAP,
      bsv.OpCode.OP_SPLIT,
      bsv.OpCode.OP_DROP,

      // 2. Hash type OpCode
      ({type = defaultRHash}) => RPuzzleTypes[type].op,

      // 3. rBufHash
      ({ type = defaultRHash, rBuf }) => RPuzzleTypes[type].hash(rBuf),

      // 4. OpCodes
      bsv.OpCode.OP_EQUALVERIFY,
      bsv.OpCode.OP_CHECKSIG
    ],

    /**
     * Returns the size of the script.
     * 
     * @param {Object} params Cast params
     * @returns {Number}
     */
    size({ type = defaultRHash }) {
      return 12 + (RPuzzleTypes[type].op ? 1 : 0) + RPuzzleTypes[type].size
    },

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(params) {
      if (!(params.rBuf && buffer.Buffer.isBuffer(params.rBuf))) {
        throw new Error('P2RPH lockingScript requires rBuf')
      }
    }
  },

  /**
   * P2RPH unlockingScript
   * 
   * The expected unlock parameters are:
   * 
   * * `kBuf` - the K value in a Buffer or typed array
   * * `keyPair` - the bsv KeyPair to sign with (will generate ephemeral key if blank)
   * 
   * Example:
   * 
   * ```
   * // Creates unlockingScript from UTXO
   * Cast.unlockingScript(P2RPH, { txid, txOutNum, txOut, nSequence })
   * 
   * // Sign the unlockingScript with kBuf and keyPair (assuming vin 0)
   * forge.signTxIn(0, { kBuf, keyPair })
   * ```
   */
  unlockingScript: {
    script: [
      // 1. Sig
      function(ctx, {
        kBuf,
        keyPair,
        sighashType = bsv.Sig.SIGHASH_ALL | bsv.Sig.SIGHASH_FORKID,
        flags = bsv.Interp.SCRIPT_VERIFY_MINIMALDATA | bsv.Interp.SCRIPT_ENABLE_SIGHASH_FORKID | bsv.Interp.SCRIPT_ENABLE_MAGNETIC_OPCODES | bsv.Interp.SCRIPT_ENABLE_MONOLITH_OPCODES
      }) {
        const {tx, txOutNum, txOut} = ctx;
        const hashBuf = tx.sighash(sighashType, txOutNum, txOut.script, txOut.valueBn, flags);
        const sig = new bsv.Ecdsa()
          .fromObject({
            hashBuf,
            keyPair,
            endian: 'little',
            k: bsv.Bn.fromBuffer(kBuf)
          })
          .sign().sig;

        sig.fromObject({ nHashType: sighashType });
        return sig.toTxFormat()
      },

      // 2. PubKey
      (_ctx, { keyPair }) => keyPair.pubKey.toBuffer()
    ],

    /**
     * Returns the size of the script.
     * 
     * @property {Object} size Script size
     */
    size: 107,

    /**
     * Generats a random bsv KeyPair if not already defined
     * 
     * @param {Object} params Cast params
     * @returns {Object}
     */
    setup({ keyPair }) {
      if (!keyPair) keyPair = bsv.KeyPair.fromRandom();
      return { keyPair }
    },

    /**
     * Validates the given params.
     * 
     * @param {Object} params Cast params
     */
    validate(ctx, params) {
      if (!(params.kBuf && verifyKBuf(params.kBuf, ctx.txOut))) {
        throw new Error('P2RPH unlockingScript requires valid kBuf')
      }
    }
  }
};


// The available hashing algos
// Use PayToR to pay to the bare R value
const RPuzzleTypes = {
  PayToRHASH160: {
    op: bsv.OpCode.OP_HASH160,
    hash: bsv.Hash.sha256Ripemd160,
    size: 20
  },
  PayToRRIPEMD160: {
    op: bsv.OpCode.OP_RIPEMD160,
    hash: bsv.Hash.ripemd160,
    size: 20
  },
  PayToRSHA256: {
    op: bsv.OpCode.OP_SHA256,
    hash: bsv.Hash.sha256,
    size: 32
  },
  PayToRHASH256: {
    op: bsv.OpCode.OP_HASH256,
    hash: bsv.Hash.sha256Sha256,
    size: 32
  },
  PayToRSHA1: {
    op: bsv.OpCode.OP_SHA1,
    hash: bsv.Hash.sha1,
    size: 20
  },
  PayToR: {
    hash: (r) => { return r },
    size: 32
  }
};

// Helper function verifies the kBuf matches the R Hash in txOut
function verifyKBuf(kBuf, { script }) {
  const rBuf = getRBuf(kBuf);

  // Pay to Rpuzzle Hash
  if (script.chunks.length === 13) {
    let type = Object.keys(RPuzzleTypes)
      .filter(key => RPuzzleTypes[key].op === script.chunks[9].opCodeNum)
      .map(key => RPuzzleTypes[key])[0];

    return !!(
      script.chunks[9].opCodeNum &&
      script.chunks[10].buf &&
      buffer.Buffer.compare(script.chunks[10].buf, type.hash(rBuf)) === 0
    )
    
  // Pay to Rpuzzle R value
  } else if (script.chunks.length === 12) {
    return !!(
      script.chunks[9].buf &&
      buffer.Buffer.compare(script.chunks[9].buf, rBuf) === 0
    )
  
  // Just false
  } else {
    return false
  }
}

// Helper function converts kBuf to rBuf
function getRBuf(kBuf) {
  const k = bsv.Bn.fromBuffer(kBuf),
        G = bsv.Point.getG(),
        N = bsv.Point.getN(),
        Q = G.mul(k),
        r = buffer.Buffer.from( Q.x.umod(N).toArray() );

  return r[0]>127 ? buffer.Buffer.concat([buffer.Buffer.alloc(1), r]) : r;
}

// Constants
const DUST_LIMIT = 546;

// Default Forge options
const defaults = {
  debug: false,
  rates: {
    data: 0.5,
    standard: 0.5
  }
};

/**
 * Forge transaction builder class.
 */
class Forge {
  /**
   * Instantiates a new Forge instance.
   * 
   * The accepted params are:
   * 
   * * `inputs` - list of input objects or cast instances
   * * `outputs` - list of output objects or cast instances
   * * `changeTo` - address to send change to
   * * `changeScript` - bsv Script object to send change to
   * * `options` - set `rates` or `debug` options
   * 
   * @param {Object} params Tx parameters
   * @constructor
   */
  constructor({
    inputs,
    outputs,
    changeTo,
    changeScript,
    options
  } = {}) {
    this.tx = new bsv.Tx();
    this.inputs = [];
    this.outputs = [];
    this.options = {
      ...defaults,
      ...options
    };

    this.addInput(inputs);
    this.addOutput(outputs);

    if (changeTo) {
      this.changeTo = changeTo;
    } else if (changeScript) {
      this.changeScript = changeScript;
    }

    debug.call(this, 'Forge:', {
      inputs: this.inputs,
      outputs: this.outputs
    });
  }

  /**
   * Returns the tx change address.
   * 
   * @type {String}
   */
  get changeTo() {
    if (this.changeScript) {
      const pkh = this.changeScript.chunks[2];
      return bsv.Address.fromPubKeyHashBuf(pkh.buf).toString()
    } 
  }

  /**
   * Sets the given address as the change address.
   * 
   * @type {String}
   */
  set changeTo(address) {
    this.changeScript = bsv.Address.fromString(address).toTxOutScript();
  }

  /**
   * The sum of all inputs.
   * 
   * @type {Number}
   */
  get inputSum() {
    return this.inputs.reduce((sum, { txOut }) => {
      return sum + txOut.valueBn.toNumber()
    }, 0)
  }

  /**
   * The sum of all outputs.
   * 
   * @type {Number}
   */
  get outputSum() {
    return this.outputs.reduce((sum, { satoshis }) => {
      return sum + satoshis
    }, 0)
  }

  /**
   * Adds the given input to the tx.
   * 
   * The input should be a Cast instance, otherwise the given params will be
   * used to instantiate a P2PKH Cast.
   * 
   * @param {Cast | Object} input Input Cast or P2PKH UTXO params
   * @returns {Forge}
   */
  addInput(input = []) {
    if (Array.isArray(input)) {
      return input.forEach(i => this.addInput(i))
    }

    if (Object.getPrototypeOf(input.constructor).name === 'Cast') {
      this.inputs.push(input);
    } else {
      const cast = Cast.unlockingScript(P2PKH, input);
      this.inputs.push(cast);
    }

    return this
  }

  /**
   * Adds the given output params to the tx.
   * 
   * The params object should contain one of the following properties:
   * 
   * * `to` - Bitcoin address to create P2PKH output
   * * `script` - hex encoded output script
   * * `data` - array of chunks which will be automatically parsed into an OP_RETURN script
   * 
   * Unless the output is an OP_RETURN data output, the params must contain a
   * `satoshis` property reflecting the number of satoshis to send.
   * 
   * For advanced use, Cast instances can be given as outputs. This allows
   * sending to non-standard and custom scripts.
   * 
   * @param {Object} output Output params
   * @returns {Forge}
   */
  addOutput(output = []) {
    if (Array.isArray(output)) {
      return output.forEach(o => this.addOutput(o))
    }

    if (Object.getPrototypeOf(output.constructor).name === 'Cast') {
      this.outputs.push(output);
    } else {
      const satoshis = output.satoshis || output.amount || 0;
      let cast;
      if (output.script) {
        // If its already script we can create a fake cast
        const script = bsv.Script.fromHex(output.script);
        cast = { satoshis, script: _ => script };
      } else if (output.data) {
        cast = Cast.lockingScript(OP_RETURN, { satoshis, data: output.data });
      } else if (output.to) {
        const address = bsv.Address.fromString(output.to);
        cast = Cast.lockingScript(P2PKH, { satoshis, address });
      } else {
        throw new Error('Invalid TxOut params')
      }
      this.outputs.push(cast);
    }

    return this
  }

  /**
   * Builds the transaction on the forge instance.
   * 
   * `build()` must be called first before attempting to sign. The
   * `unlockingScripts` are generated with signatures and other dynamic push
   * data zeroed out.
   * 
   * @returns {Forge}
   */
  build() {
    // Create a new tx
    this.tx = new bsv.Tx();

    // Iterate over inputs and add placeholder unlockingScripts
    this.inputs.forEach(cast => {
      const size = cast.getSize() - 40,
            buf = buffer.Buffer.alloc(size),
            script = new bsv.Script().fromBuffer(buf);
            
      this.tx.addTxIn(cast.txHashBuf, cast.txOutNum, script, cast.nSequence);
    });

    // Iterate over outputs and add to tx
    this.outputs.forEach(cast => {
      const script = cast.getScript();
      const isOpReturn = (script.chunks[0].opCodeNum === bsv.OpCode.OP_RETURN ||
        (script.chunks[0].opCodeNum === bsv.OpCode.OP_FALSE && script.chunks[1].opCodeNum === bsv.OpCode.OP_RETURN)
      );
      if (cast.satoshis < DUST_LIMIT && !isOpReturn) {
        throw new Error('Cannot create output lesser than dust')
      }
      this.tx.addTxOut(bsv.Bn(cast.satoshis), script);
    });
    
    // If necessary, add the changeScript
    if (this.changeScript) {
      let change = this.inputSum - this.outputSum - this.estimateFee();
      
      // If no outputs we dont need to make adjustment for change
      // as it is already factored in to fee estimation
      if (this.outputs.length > 0) {
        // Size of change script * 0.5
        change -= 16;
      }

      if (change > DUST_LIMIT) {
        this.tx.addTxOut(bsv.TxOut.fromProperties(bsv.Bn(change), this.changeScript));
      }
    }
    
    return this
  }

  /**
   * Iterates over the inputs and generates the `unlockingScript` for each TxIn.
   * Must be called after `build()`.
   * 
   * The given `params` will be passed to each Cast instance. For most standard
   * transactions this is all that is needed. For non-standard transaction types
   * try calling `signTxIn(vin, params)` on individual inputs.
   * 
   * @param {Object} params unlockingScript params
   * @returns {Forge}
   */
  sign(params) {
    if (this.inputs.length !== this.tx.txIns.length) {
      throw new Error('TX not built. Call `build()` first.')
    }

    for (let i = 0; i < this.inputs.length; i++) {
      try {
        this.signTxIn(i, params);
      } catch(e) {
        debug.call(this, 'Forge:', e.message, { i, params });
      }
    }
  }

  /**
   * Generates the `unlockingScript` for the TxIn specified by the given index.
   * 
   * The given `params` will be passed to each Cast instance. This is useful for
   * non-standard transaction types as tailored `unlockingScript` params can be
   * passed to each Cast instance.
   * 
   * @param {Number} vin Input index
   * @param {Object} params unlockingScript params
   */
  signTxIn(vin, params) {
    if (!(
      this.inputs[vin] &&
      this.tx.txIns[vin] &&
      buffer.Buffer.compare(this.inputs[vin].txHashBuf, this.tx.txIns[vin].txHashBuf) === 0
    )) {
      throw new Error('TX not built. Call `build()` first.')
    }

    const cast = this.inputs[vin],
          script = cast.getScript(this, params);

    this.tx.txIns[vin].setScript(script);
    return this
  }

  /**
   * Estimates the fee of the current inputs and outputs.
   * 
   * Will use the given miner rates, assuming they are in the Minercraft rates
   * format. If not given. will use the default rates set on the Forge instance.
   * 
   * @param {Object} rates Miner Merchant API rates
   * @returns {Number}
   */
  estimateFee(rates = this.options.rates) {
    const parts = [
      { standard: 4 }, // version
      { standard: 4 }, // locktime
      { standard: bsv.VarInt.fromNumber(this.inputs.length).buf.length },
      { standard: bsv.VarInt.fromNumber(this.outputs.length).buf.length },
    ];

    if (this.inputs.length > 0) {
      this.inputs.forEach(cast => {
        parts.push({ standard: cast.getSize() });
      });
    } else {
      // Assume single p2pkh script
      parts.push({ standard: 148 });
    }

    if (this.outputs.length > 0) {
      this.outputs.forEach(cast => {
        const p = {},
              script = cast.getScript(),
              txOut = bsv.TxOut.fromProperties(bsv.Bn(cast.satoshis), script);

        const type = script.chunks[0].opCodeNum === 0 && script.chunks[1].opCodeNum === 106 ? 'data' : 'standard';
        p[type] = 8 + txOut.scriptVi.buf.length + txOut.scriptVi.toNumber();
        parts.push(p);
      });
    } else if (this.changeScript) {
      // Assume single p2pkh output
      const change = bsv.TxOut.fromProperties(bsv.Bn(0), this.changeScript),
            changeSize = 8 + change.scriptVi.buf.length + change.scriptVi.toNumber();
      parts.push({ standard: changeSize });
    }

    const fee = parts.reduce((fee, p) => {
      return Object
        .keys(p)
        .reduce((acc, k) => {
          const bytes = p[k],
                rate = rates[k];
          return acc + (bytes * rate)
        }, fee)
    }, 0);
    return Math.ceil(fee)
  }
}


// Log the given arguments if debug mode enabled
function debug(...args) {
  if (this.options.debug) {
    console.log(...args);
  }
}

exports.Cast = Cast;
exports.Forge = Forge;
